/*
 * Copyright (c) 2018 Villu Ruusmann
 *
 * This file is part of JPMML-Python
 *
 * JPMML-Python is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * JPMML-Python is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with JPMML-Python.  If not, see <http://www.gnu.org/licenses/>.
 */
options {
	JAVA_TEMPLATE_TYPE = "modern";
	JDK_VERSION = "1.8";
	STATIC = false;
	BUILD_TOKEN_MANAGER = false;
}

PARSER_BEGIN(PredicateTranslator)
package org.jpmml.python;

import java.util.ArrayList;
import java.util.List;

import org.dmg.pmml.Array;
import org.dmg.pmml.CompoundPredicate;
import org.dmg.pmml.False;
import org.dmg.pmml.Predicate;
import org.dmg.pmml.SimplePredicate;
import org.dmg.pmml.SimpleSetPredicate;
import org.dmg.pmml.True;
import org.jpmml.converter.Feature;
import org.jpmml.converter.PMMLUtil;

public class PredicateTranslator extends AbstractTranslator {

	public PredicateTranslator(Scope scope){
		this(new NullProvider());

		setScope(scope);
	}

	public Predicate translatePredicate(String string){
		ReInit(new StringProvider(string));

		Predicate predicate;

		try {
			predicate = translatePredicateInternal();
		} catch(ParseException pe){
			throw new IllegalArgumentException("Python predicate \'" + string + "\' is either invalid or not supported", pe);
		}

		return predicate;
	}

	static
	private SimplePredicate.Operator translateRelationalOperator(Token operator) throws ParseException {
		
		switch(operator.kind){
			case EQUAL:
				return SimplePredicate.Operator.EQUAL;
			case NOT_EQUAL:
				return SimplePredicate.Operator.NOT_EQUAL;
			case LESS_THAN:
				return SimplePredicate.Operator.LESS_THAN;
			case LESS_OR_EQUAL:
				return SimplePredicate.Operator.LESS_OR_EQUAL;
			case GREATER_THAN:
				return SimplePredicate.Operator.GREATER_THAN;
			case GREATER_OR_EQUAL:
				return SimplePredicate.Operator.GREATER_OR_EQUAL;
			default:
				throw new ParseException();
		}
	}

	static
	private Object translateValue(Token value) throws ParseException {
		String image = value.image;
		
		switch(value.kind){
			case FALSE:
				return False.INSTANCE;
			case TRUE:
				return True.INSTANCE;
			case INT:
				return translateInt(image);
			case FLOAT:
				return image;
			case STRING:
				return translateString(image);
			default:
				throw new ParseException();
		}
	}

	static
	private SimplePredicate createSimplePredicate(Object left, SimplePredicate.Operator operator, Object right){
		Feature feature = asFeature(left);
		String value = (right != null ? asValue(right) : null);

		return new SimplePredicate(feature.getName(), operator, value);
	}

	static
	private SimpleSetPredicate createSimpleSetPredicate(Object left, SimpleSetPredicate.BooleanOperator booleanOperator, Object right){
		Feature feature = asFeature(left);
		Array array = (Array)right;

		return new SimpleSetPredicate(feature.getName(), booleanOperator, array);
	}

	static
	private CompoundPredicate createCompoundPredicate(CompoundPredicate.BooleanOperator booleanOperator, Predicate... predicates){
		CompoundPredicate compoundPredicate = new CompoundPredicate(booleanOperator, null)
			.addPredicates(predicates);

		return compoundPredicate;
	}

	static
	private Feature asFeature(Object object){

		if(object instanceof Feature){
			return (Feature)object;
		} else

		{
			throw new IllegalArgumentException("The left-hand side is not a feature reference");
		}
	}

	static
	private String asValue(Object object){

		if(object instanceof False){
			return "false";
		} else

		if(object instanceof True){
			return "true";
		} else

		if(object instanceof String){
			return (String)object;
		} else

		{
			throw new IllegalArgumentException("The right-hand side is not a value (" + object + ")");
		}
	}
}
PARSER_END(PredicateTranslator)

@python.tokens@

private Predicate translatePredicateInternal():
{
	Predicate predicate;
}
{
	predicate = Predicate() <EOF>

	{
		return predicate;
	}
}

private Predicate Predicate():
{
	Predicate predicate;
}
{
	predicate = LogicalOrExpression()

	{
		return predicate;
	}
}

private Predicate LogicalOrExpression():
{
	Predicate left;
	Predicate right;
}
{
	left = LogicalAndExpression() ( <OR> right = LogicalAndExpression() { left = createCompoundPredicate(CompoundPredicate.BooleanOperator.OR, left, right); } )*

	{
		return left;
	}
}

private Predicate LogicalAndExpression():
{
	Predicate left;
	Predicate right;
}
{
	left = ComparisonExpression() ( <AND> right = ComparisonExpression() { left = createCompoundPredicate(CompoundPredicate.BooleanOperator.AND, left, right); } )*

	{
		return left;
	}
}

private Predicate ComparisonExpression():
{
	Object left;
	Token operator = null;
	Object right;
}
{
	(
		LOOKAHEAD(PrimaryExpression() <IS> <NONE>)
		left = PrimaryExpression() <IS> <NONE> { left = createSimplePredicate(left, SimplePredicate.Operator.IS_MISSING, null); }
		|
		LOOKAHEAD(PrimaryExpression() <IS> <NOT> <NONE>)
		left = PrimaryExpression() <IS> <NOT> <NONE> { left = createSimplePredicate(left, SimplePredicate.Operator.IS_NOT_MISSING, null); }
		|
		LOOKAHEAD(PrimaryExpression() <IN>)
		left = PrimaryExpression() <IN> right = ListMakerExpression() { left = createSimpleSetPredicate(left, SimpleSetPredicate.BooleanOperator.IS_IN, right); }
		|
		LOOKAHEAD(PrimaryExpression() <NOT> <IN>)
		left = PrimaryExpression() <NOT> <IN> right = ListMakerExpression() { left = createSimpleSetPredicate(left, SimpleSetPredicate.BooleanOperator.IS_NOT_IN, right); }
		|
		left = PrimaryExpression() ((operator = <EQUAL> | operator = <NOT_EQUAL> | operator = <LESS_THAN> | operator = <LESS_OR_EQUAL> | operator = <GREATER_THAN> | operator = <GREATER_OR_EQUAL>) right = UnaryExpression() { left = createSimplePredicate(left, translateRelationalOperator(operator), right); } )?
	)

	{
		return (Predicate)left;
	}
}

private Object UnaryExpression():
{
	Token sign = null;
	Object result;
}
{
	(
		sign = Sign() result = UnaryExpression()
		|
		result = PrimaryExpression()
	)

	{
		if(sign != null && sign.kind == MINUS){
			String value = (String)result;

			if(value.startsWith("-")){
				value = value.substring(1);
			} else

			{
				value = ("-" + value);
			}

			result = value;
		}

		return result;
	}
}

private Object PrimaryExpression():
{
	Object result;
}
{
	(
		LOOKAHEAD(<NAME> <LBRACKET>)
		result = ArrayIndexingExpression()
		|
		result = NameInvocationExpression()
		|
		result = ParenthesizedExpression()
		|
		result = LiteralExpression()
	)

	{
		return result;
	}
}

private Feature ArrayIndexingExpression():
{
	Token name;
	Token sign = null;
	Token column;

	Feature feature;
}
{
	(
		LOOKAHEAD(<NAME> <LBRACKET> (Sign())? <INT>)
		name = <NAME> <LBRACKET> (sign = Sign())? column = <INT> <RBRACKET> {
			Scope scope = ensureScope();

			int colIndex = parseInt(sign, column);

			feature = scope.getFeature(name.image, colIndex);
		}
		|
		name = <NAME> <LBRACKET> column = <STRING> <RBRACKET> {
			Scope scope = ensureScope();

			String colName = translateString(column.image);

			feature = scope.getFeature(name.image, colName);
		}
	)

	{
		return feature;
	}
}

private Feature NameInvocationExpression():
{
	Token name;
}
{
	name = <NAME>

	{
		Scope scope = ensureScope();

		Feature feature = scope.getFeature(name.image);

		return feature;
	}
}

private Predicate ParenthesizedExpression():
{
	Predicate predicate;
}
{
	<LPAREN> predicate = Predicate() <RPAREN>

	{
		return predicate;
	}
}

private Object LiteralExpression():
{
	Token value;
}
{
	(
		value = <FALSE>
		|
		value = <TRUE>
		|
		value = <INT>
		|
		value = <FLOAT>
		|
		value = <STRING>
	)

	{
		return translateValue(value);
	}
}

private Array ListMakerExpression():
{
	Object predicate;
	
	List<String> values = new ArrayList<String>();
}
{
	<LBRACKET> predicate = UnaryExpression() { values.add(asValue(predicate)); } ( <COMMA> predicate = UnaryExpression() { values.add(asValue(predicate)); } )* <RBRACKET>
	
	{
		return PMMLUtil.createStringArray(values);
	}
}
